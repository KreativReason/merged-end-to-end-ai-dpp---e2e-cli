#!/usr/bin/env python3
"""
Scaffold Apply Script (Stage 2)

Applies an approved scaffolding plan to the repository by creating the
declared directory structure and generating placeholder files listed
in the plan's templates_to_apply.files_to_generate entries.

This script enforces human approval gates and validates inputs against
Pydantic models defined in app.models. It emits a single JSON object to
STDOUT describing the apply results, conforming to the Scaffolder agent's
"apply mode" output schema.
"""

import argparse
import json
import os
import stat
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Tuple

from pydantic import ValidationError

try:
    # Prefer absolute import when executed from repo root
    from app.models import ScaffoldPlanModel, PRDModel, ERDModel, ErrorModel
except Exception:  # pragma: no cover
    # Fallback for direct execution from subdirectories
    sys.path.append(str(Path(__file__).resolve().parents[1]))
    from app.models import ScaffoldPlanModel, PRDModel, ERDModel, ErrorModel  # type: ignore


REQUIRED_APPROVERS = {"Cynthia", "Usama"}


def load_json(path: Path) -> Dict[str, Any]:
    return json.loads(path.read_text())


def validate_inputs(prd_path: Path, erd_path: Path, plan_path: Path) -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:
    prd = load_json(prd_path)
    erd = load_json(erd_path)
    plan = load_json(plan_path)

    # Pydantic validation
    try:
        PRDModel(**prd)
    except ValidationError as e:
        raise ValueError(f"PRD validation failed: {e}")

    try:
        ERDModel(**erd)
    except ValidationError as e:
        raise ValueError(f"ERD validation failed: {e}")

    try:
        ScaffoldPlanModel(**plan)
    except ValidationError as e:
        raise ValueError(f"Scaffold plan validation failed: {e}")

    # Basic consistency checks
    prj_prd = prd.get("data", {}).get("project_name")
    prj_erd = erd.get("data", {}).get("project_name")
    prj_plan = plan.get("data", {}).get("project_name")
    if len({prj_prd, prj_erd, prj_plan}) != 1:
        raise ValueError("Inconsistent project_name across PRD, ERD, and scaffold plan")

    return prd, erd, plan


def require_approval(provided_approvers: List[str]) -> None:
    provided = set(a.strip() for a in provided_approvers)
    missing = REQUIRED_APPROVERS - provided
    if missing:
        raise PermissionError(
            f"Missing required approvers: {', '.join(sorted(missing))}"
        )


def ensure_directory(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)


def write_placeholder_file(path: Path, project_name: str) -> None:
    ensure_directory(path.parent)
    content = generate_placeholder_content(path, project_name)
    if not path.exists():
        path.write_text(content)
    else:
        # Preserve existing files; do not overwrite
        pass


def generate_placeholder_content(path: Path, project_name: str) -> str:
    suffix = path.suffix.lower()
    if suffix in {".py"}:
        return (
            '"""\n'
            'Auto-generated placeholder file.\n\n'
            'This file was created by the scaffold apply process. Replace with real content\n'
            'from templates when available.\n'
            '"""\n\n'
            'if __name__ == "__main__":\n'
            '    print("{project_name} placeholder: {path}")\n'
        ).format(project_name=project_name, path=str(path))
    if suffix in {".ts", ".tsx", ".js", ".jsx"}:
        return (
            """// Auto-generated placeholder file for {project_name}\nexport default function Placeholder() {{\n  return (<div>Placeholder: {path}</div>);\n}}\n"""
        ).format(project_name=project_name, path=str(path))
    if suffix in {".sql"}:
        return (
            """-- Auto-generated placeholder migration for {project_name}\n-- File: {path}\n"""
        ).format(project_name=project_name, path=str(path))
    if suffix in {".json"}:
        return json.dumps({"placeholder": True, "project": project_name, "path": str(path)}, indent=2)
    if suffix in {".md"}:
        return f"# Placeholder\n\nFile: {path}\n\nProject: {project_name}\n"
    if path.name == "Makefile":
        return "# Placeholder Makefile generated by scaffold apply\n\n.DEFAULT_GOAL := help\n\nhelp:\n\t@echo 'Replace this placeholder with real Makefile content.'\n"
    # Default text
    return f"// Placeholder for {project_name}: {path}\n"


def collect_fs_metadata(path: Path) -> Dict[str, Any]:
    st = path.stat()
    perm = stat.S_IMODE(st.st_mode)
    return {
        "path": str(path).replace("\\", "/"),
        "size_bytes": st.st_size,
        "permissions": f"{perm:o}",
    }


def apply_plan(plan: Dict[str, Any], project_root: Path, dry_run: bool) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    files_created: List[Dict[str, Any]] = []
    templates_applied: List[Dict[str, Any]] = []

    data = plan.get("data", {})
    project_name = data.get("project_name", "Project")

    # Ensure directory structure
    directory_structure = data.get("directory_structure", {})
    for dir_path in directory_structure.keys():
        target_dir = (project_root / dir_path).resolve()
        if not dry_run:
            ensure_directory(target_dir)

    # Apply templates (best-effort placeholder generation)
    for template in data.get("templates_to_apply", []):
        template_id = template.get("id")
        target_path = template.get("target_path", "")
        files = template.get("files_to_generate", [])

        created_count = 0
        created_dirs: set[str] = set()

        for rel_file in files:
            # FIX: Properly combine target_path with rel_file
            # If rel_file already starts with target_path, don't duplicate it
            if target_path and not rel_file.startswith(target_path):
                full_path = f"{target_path.rstrip('/')}/{rel_file}"
            else:
                full_path = rel_file

            file_path = (project_root / full_path).resolve()
            if not dry_run:
                write_placeholder_file(file_path, project_name)
            if file_path.exists():
                files_created.append(collect_fs_metadata(file_path))
                created_count += 1
                created_dirs.add(str(file_path.parent))

        templates_applied.append({
            "template_id": template_id,
            "status": "success" if created_count == len(files) else "partial",
            "files_created": created_count,
            "directories_created": len(created_dirs),
        })

    return files_created, templates_applied


def emit_error(code: str, message: str, details: List[str]) -> None:
    err = {
        "error": {
            "code": code,
            "message": message,
            "details": details,
            "artifact": "scaffold",
            "remediation": "Check template paths, approvals, and input artifacts"
        }
    }
    print(json.dumps(err, indent=2))
    sys.exit(1)


def main() -> None:
    parser = argparse.ArgumentParser(description="Apply an approved scaffold plan")
    parser.add_argument("--plan", required=True, help="Path to docs/scaffold_plan.json")
    parser.add_argument("--prd", required=True, help="Path to PRD JSON")
    parser.add_argument("--erd", required=True, help="Path to ERD JSON")
    parser.add_argument("--approved-by", action="append", default=[], help="Approver name (can be repeated)")
    parser.add_argument("--output", required=True, help="Path to write scaffold_applied JSON result")
    parser.add_argument("--project-dir", help="Target directory for generated project (default: ../generated-projects/{project-name})")
    parser.add_argument("--dry-run", action="store_true", help="Validate and report without creating files")

    args = parser.parse_args()

    plan_path = Path(args.plan).resolve()
    prd_path = Path(args.prd).resolve()
    erd_path = Path(args.erd).resolve()
    output_path = Path(args.output).resolve()

    # Load plan to get project name for default directory
    plan_data = load_json(plan_path)
    project_name = plan_data.get("data", {}).get("project_name", "unknown-project")
    project_name_slug = project_name.lower().replace(" ", "-")

    # Determine project root: use --project-dir if provided, else default to ../generated-projects/{project-name}
    if args.project_dir:
        project_root = Path(args.project_dir).resolve()
    else:
        # Default: ../generated-projects/{project-name-slug}/
        factory_root = Path(__file__).resolve().parents[1]  # Parent of scripts/ is factory root
        project_root = (factory_root / ".." / "generated-projects" / project_name_slug).resolve()

    try:
        prd, erd, plan = validate_inputs(prd_path, erd_path, plan_path)
        # Enforce approval gate
        require_approval(args.approved_by)

        # Apply plan
        files_created, templates_applied = apply_plan(plan, project_root, args.dry_run)

        now = datetime.now(timezone.utc).isoformat()
        result = {
            "artifact_type": "scaffold_applied",
            "status": "complete",
            "validation": "passed",
            "approval_required": False,
            "next_phase": "development",
            "data": {
                "project_name": plan.get("data", {}).get("project_name"),
                "project_root": str(project_root),
                "applied_at": now,
                "mode": "apply",
                "templates_applied": templates_applied,
                "files_created": files_created,
                "post_apply_actions": [
                    {"action": "pip install -r requirements.txt", "directory": ".", "status": "pending", "output": ""},
                    {"action": "npm install", "directory": "frontend/", "status": "pending", "output": ""}
                ],
                "validation_results": {
                    "syntax_valid": True,
                    "dependencies_resolved": False,
                    "tests_passing": False
                },
                "setup_instructions": [
                    "Copy .env.example to .env and fill in values",
                    "Run 'docker compose up -d' to start services (if applicable)",
                    "Run 'npm run dev' in frontend and start backend app"
                ]
            }
        }

        # Persist result
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(json.dumps(result, indent=2))

        # Emit to STDOUT as well (JSON-only)
        print(json.dumps(result, indent=2))
        sys.exit(0)

    except PermissionError as e:
        emit_error("APPROVAL_REQUIRED", str(e), ["Provide --approved-by Cynthia --approved-by Usama"])  # nosec
    except FileNotFoundError as e:
        emit_error("FILE_NOT_FOUND", str(e), ["Verify input paths exist"])  # nosec
    except ValueError as e:
        emit_error("VALIDATION_FAILED", str(e), ["Run linters: python -m app.lint_prd, python -m app.lint_erd"])  # nosec
    except Exception as e:  # pragma: no cover
        emit_error("SCAFFOLD_FAILED", f"Unexpected error: {e}", [])


if __name__ == "__main__":
    main()


